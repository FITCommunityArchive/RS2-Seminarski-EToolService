#include <iostream>
#include <string>
#include<memory>
using namespace std;

template<class T>
class Kolekcija {
    T* _elementi;
    int _trenutnoElemenata;

    // Funkcija Pretrazi(T) koja pretrazuje element, ukoliko element vec postoji baca exception
    void Pretrazi(T& element) {
        if (_trenutnoElemenata == 0)
            return;
        for (int i = 0; i < _trenutnoElemenata; i++)
        {
            if (_elementi[i] == element)
                throw exception("Element vec postoji!");
        }
    }

public:
    Kolekcija() {
        _trenutnoElemenata = 0;
        _elementi = nullptr;
    }

    // Vraca element sa lokacije, ukoliko lokacija nije validna treba baciti exception sa odgovarajucom porukom
    T& GetElement(int lokacija) {
        for (int i = 0; i < _trenutnoElemenata; i++)
        {
            if (lokacija == i)
                return _elementi[i];
        }
        throw exception("Lokacija nije validna!");
    }

    // Zabraniti dodavanje istih elemenata, iskoristiti funkciju Pronadji() za provjeru da li element vec postoji
    void AddElement(T& element) {
        try
        {
            Pretrazi(element);
        }
        catch (const exception& exception)
        {
            cout << "dogodila se greska!" <<exception.what()<< endl;
            // OVDJE
            //ne znam jel treba tu vise ist jer mi u pretrazi izbacuje gresku
        }
        T* temp = new T[_trenutnoElemenata + 1];
        for (int i = 0; i < _trenutnoElemenata; i++)
        {
            temp[i] = _elementi[i];
        }
        temp[_trenutnoElemenata] = element;

        _trenutnoElemenata++;
        delete[] _elementi;
        _elementi = temp;
    }

    int GetTrenutno() const { return _trenutnoElemenata; }

    // Treba ocistiti niz (obrisati sve elemente)
    // Ako je niz prazan, funkcija treba baciti exception sa odgovarajucom porukom
    void Clear() {
        if (_elementi != nullptr)
        {
            for (int i = 0; i < _trenutnoElemenata; i++)
            {
                delete _elementi[i]; 
                _elementi[i] = nullptr;
            }
            // OVDJE
        }
        else
        {
            throw exception("Niz je prazan!");
        }
    }

    friend ostream& operator<<(ostream& cout, Kolekcija& kolekcija) {
        for (int i = 0; i < kolekcija._trenutnoElemenata; i++)
        {
            cout << kolekcija.GetElement(i) << endl;
        }
        return cout;
    }

    ~Kolekcija() {
        delete[] _elementi;
        _elementi = nullptr;
        _trenutnoElemenata = 0;
    }
};

class Datum {
    int* _dan;
    int* _mjesec;
    int* _godina;
public:
    Datum(int dan = 1, int mjesec = 1, int godina = 2000) {
        _dan = new int(dan);
        _mjesec = new int(mjesec);
        _godina = new int(godina);
    }

    friend ostream& operator<<(ostream& cout, Datum& datum) {
        return cout << *datum._dan << "/" << *datum._mjesec << "/" << *datum._godina;
    }

    Datum(const Datum& ori) {
        _dan = new int(*ori._dan);
        _mjesec = new int(*ori._mjesec);
        _godina = new int(*ori._godina);
    }

    void SetDan(int dan) {
        if (_dan == nullptr) _dan = new int;
        *_dan = dan;
    }
    void SetMjesec(int mjesec) {
        if (_mjesec == nullptr) _mjesec = new int;
        *_mjesec = mjesec;
    }
    void SetGodina(int godina) {
        if (_godina == nullptr) _godina = new int;
        *_godina = godina;
    }

    // Uz predpostavku da svaki mjesec ima 30 dana, funkcija treba da poveca datum
    // za broj dana koji proslijedimo u funkciju
    // npr. ako je datum 21.8.2020 i ako u funkciju DodajDane proslijedimo 11,
    // datum treba da se promijeni na 2.9.2020
    void DodajDane(int brojDana) { //ovo nije dobro sigurno 
        int ostatak = 0;
        int ukupno = 0;
        ukupno = (*_dan) + brojDana;
        int dani = 0;
        int mjesec = (*_mjesec);

        if (ukupno > 30)
        {
            // OVDJE   
            for (int i = 0; i <= ukupno; i+=30)
            {
                mjesec += 1;
                ostatak = ukupno - 30;
                ukupno= ukupno - 30;
            }
        }
        SetDan(ostatak);
        SetMjesec(mjesec);
    }

    Datum& operator =(const Datum& obj) {
            // OVDJE
        if (this == &obj)
            return *this;
        if (_dan == nullptr) _dan = new int;
        if (_mjesec == nullptr)	_mjesec = new int;
        if (_godina == nullptr) _godina = new int;
        *_dan = *obj._dan, * _mjesec = *obj._mjesec, * _godina = *obj._godina;
        return *this;
    }

    bool operator==(const Datum& right) {
        // OVDJE
      return *_dan = *right._dan && *_mjesec == *right._mjesec && *_godina == *right._godina;
    }

    ~Datum() {
        delete _dan;
        delete _mjesec;
        delete _godina;
        _dan = nullptr; _mjesec = nullptr; _godina = nullptr;
    }
};

class Uposlenik {
    char* _imePrezime;
    Datum _datumRodjenja;
    Datum* _datumIstekaUgovora;
    bool* _aktivan;
public:
    Uposlenik(const char* imePrezime, Datum datumRodjenja, Datum datumIstekaUgovora, bool aktivan = true) {
        _imePrezime = new char[strlen(imePrezime) + 1];
        strcpy_s(_imePrezime, strlen(imePrezime) + 1, imePrezime);
        _datumRodjenja = datumRodjenja;
        // OVDJE
        _datumIstekaUgovora = new Datum(datumIstekaUgovora);
        // OVDJE
        _aktivan = new bool(aktivan);
    }
    Uposlenik()
    {
        _imePrezime = nullptr;
        _datumIstekaUgovora = nullptr;
        _aktivan = nullptr;
    }

    void ProduziUgovor(int brojDana) {
        _datumIstekaUgovora->DodajDane(brojDana);
    }

    friend ostream& operator<<(ostream& cout, Uposlenik& uposlenik) {
        return cout << "\t" << uposlenik._imePrezime << " - Ugovor traje do: " << *uposlenik._datumIstekaUgovora;
    }

    bool IsAktivan() const { return *_aktivan; }

    // Porediti sve atribute!
    bool operator==(const Uposlenik& right) {
        // OVDJE
        return *_imePrezime == *right._imePrezime && _datumRodjenja == right._datumRodjenja && *_datumIstekaUgovora == *right._datumIstekaUgovora && *_aktivan == *right._aktivan;
    }

    ~Uposlenik() {
        delete[] _imePrezime;
        _imePrezime = nullptr;
        delete _datumIstekaUgovora;
        _datumIstekaUgovora = nullptr;
        delete _aktivan; _aktivan = nullptr;
    }
};

class Kompanija {
    string _nazivKompanije;
    Kolekcija<Uposlenik>* _aktivniUposlenici;
    Kolekcija<Uposlenik>* _neaktivniUposlenici;
public:
    Kompanija(string naziv) {
        // OVDJE
        /*_nazivKompanije = naziv;*/  /*sto ne moze odmah ovako?*/
        naziv.assign(_nazivKompanije);
        _aktivniUposlenici = nullptr;
        _neaktivniUposlenici = nullptr;
    }

    // Ukoliko je uposlenik aktivan, dodaje se u _aktivniUposlenici
    // Ukoliko je uposlenik neaktivan, dodaje se u _neaktivniUposlenici
    void DodajUposlenika(Uposlenik uposlenik) {
        if (uposlenik.IsAktivan())
        {
            _aktivniUposlenici->AddElement(uposlenik);
        }
        else
        {
            _neaktivniUposlenici->AddElement(uposlenik);
        }
    }
    void ProduziUgovorAktivnimUposlenicima(int brojDana) {

        for (int i = 0; i < _aktivniUposlenici->GetTrenutno(); i++)
        {
            _aktivniUposlenici->GetElement(i).ProduziUgovor(brojDana);
        }
    }

    friend ostream& operator<<(ostream& cout, Kompanija& kompanija) {
        cout << "\nNaziv kompanije: " << kompanija._nazivKompanije << endl << endl;
        cout << "\t\t- Aktivni uposlenici -" << endl;
        cout << *kompanija._aktivniUposlenici << endl;
        cout << "\t\t- Neaktivni uposlenici -" << endl;
        cout << *kompanija._neaktivniUposlenici << endl;
        return cout;
    }

    ~Kompanija() {
        delete _aktivniUposlenici;
        delete _neaktivniUposlenici;
        _aktivniUposlenici = nullptr;
        _neaktivniUposlenici = nullptr;
    }

};

int main() {

#pragma region Testiranje datuma
    Datum danas(21, 8, 2020);
    cout << "Danasnji datum: " << danas << endl;

    danas.DodajDane(11);
    cout << "Novi datum: " << danas << endl;

    Datum datum1(20, 3, 2019);
    Datum datum2(20, 3, 2019);
    Datum datum3(20, 3, 2019);
    Datum datum4(20, 3, 2019);
    Datum datum5(20, 3, 2019);
    Datum datum6(20, 3, 2019);

#pragma endregion

#pragma region Testiranje uposlenika

    Uposlenik uposlenik1("Uposlenik1 Prezime1", Datum(18, 5, 1996), datum1);
    Uposlenik uposlenik2("Uposlenik2 Prezime2", Datum(3, 1, 1985), datum2);
    Uposlenik uposlenik3("Uposlenik3 Prezime3", Datum(21, 4, 1992), datum3);
    Uposlenik uposlenik4("Uposlenik4 Prezime4", Datum(17, 12, 1997), datum4, false);
    Uposlenik uposlenik5("Uposlenik5 Prezime5", Datum(30, 3, 1973), datum5);
    Uposlenik uposlenik6("Uposlenik6 Prezime6", Datum(1, 7, 1981), datum6);
    Uposlenik uposlenik7("Uposlenik7 Prezime7", Datum(11, 2, 1970), datum1, false);

    cout << "Uposlenik 1: " << uposlenik1 << endl;
    uposlenik1.ProduziUgovor(65);   // Ugovor produzen za 65 dana (dva mjeseca i 5 dana)
    cout << "Uposlenik 1: " << uposlenik1 << endl;

#pragma endregion

#pragma region Testiranje kompanije

    Kompanija authority("Authority Partners");
    Kompanija mistral("Mistral");

    authority.DodajUposlenika(uposlenik4);
    authority.DodajUposlenika(uposlenik2);
    authority.DodajUposlenika(uposlenik2);  // Dva puta isti uposlenik
    authority.DodajUposlenika(uposlenik6);

    cout << authority << endl;

    authority.ProduziUgovorAktivnimUposlenicima(126); // 126 dana = 3 mjeseca i 6 dana

    cout << "\n\t\t\tNakon produzavanja ugovora: " << authority << endl;

    // Sve zamijeniti osim naziva kompanije,
    // Dakle kompanija mistral zadrÅ¾ava svoj naziv a treba da sadrzi sve uposlenike kompanije authority
    mistral = authority;

    cout << mistral << endl;

#pragma endregion

    system("pause>0");
    return 0;
}